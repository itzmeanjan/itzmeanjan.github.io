<!DOCTYPE html>
<!--
  Author: Anjan Roy<hello@itzmeanjan.in>
-->
<html>

<head>
    <title>
        P2P Sync - A Network Coding based Protocol Design
    </title>
    <meta prefix="og: http://ogp.me/ns#" property="og:type" content="website">
    <meta prefix="og: http://ogp.me/ns#" property="og:title"
        content="P2P Sync - A Network Coding based Protocol Design">
    <meta prefix="og: http://ogp.me/ns#" property="og:description" content="">
    <meta prefix="og: http://ogp.me/ns#" property="og:url" content="https://itzmeanjan.in">
    <meta prefix="og: http://ogp.me/ns#" property="og:image" content="https://itzmeanjan.in/images/myImage.jpg">
    <meta prefix="og: http://ogp.me/ns#" property="og:image:secure_url"
        content="https://itzmeanjan.in/images/myImage.jpg">
    <meta prefix="og: http://ogp.me/ns#" property="og:image:width" content="950">
    <meta prefix="og: http://ogp.me/ns#" property="og:image:height" content="735">
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://itzmeanjan.in/">
    <meta property="twitter:title" content="P2P Sync - A Network Coding based Protocol Design">
    <meta property="twitter:description" content="">
    <meta property="twitter:image" content="https://itzmeanjan.in/images/myImage.jpg">
    <meta property="twitter:site" content="@meanjanry">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Anjan Roy">
    <meta name="keywords"
        content="anjan, roy, itzmeanjan, software, engineer, india, portfolio, skills, projects, thoughts, experiments, experiences">
    <meta name="theme-color" content="darkslategrey">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" type="text/css" href="../styles/index.css">
    <script src="../styles/code.js"></script>
</head>

<body>
    <div id="parentDiv">
        <div id="navBar">
            <nav>
                <a class="navLink" href="/"><big>H</big>ome</a> |
                <a class="navLink" href="https://github.com/itzmeanjan" target="_blank"><big>P</big>rojects</a> |
                <a class="navLink" href="/pages/blog.html"><big>B</big>log</a> |
                <a class="navLink" href="/pages/contact.html"><big>C</big>ontact</a>
            </nav>
        </div>
        <div class="childDiv">
            <article>
                <h1 class="blogHeader">
                    P2P Sync - A Network Coding based Protocol Design
                </h1>
                <h3>Created : July 15, 2021</h3>
            </article>
        </div>
        <div class="childDiv">
            <article>
                <p class="blogText">
                    After studying <b>R</b>andom <b>L</b>inear <b>N</b>etwork <b>C</b>oding for last few weeks,
                    I've decided to make use of it for designing data syncing protocol in p2p network. Client-server
                    model works pretty well, but I can make better use of bandwidth of all participants
                    when each plays role of both client & server. Assuming a chunk of data, which is owned
                    by only one peer, has suddenly become popular. Lots of peers who has interest in that chunk
                    could directly ask the only owner for chunk --- resulting into heavy load on owner.
                    But one thing to notice, as interested peers prograssively keep owning some portion of
                    chunk, they could also help others with what they have now. This way only owner doesn't end up
                    feeding all interested parties, rather interested parties also feed other interested parties.
                    This calls for decentralised coordination --- which is <i>not so easy</i>. In p2p networks,
                    piece collection is an important problem, where each interested peer tries to collect all pieces
                    of whole data chunk. Because if owner sends whole chunk as a single entity, coordination
                    is harder to define & manage, rather data chunk is splitted into multiple smaller pieces.
                    Now interested peers will attempt to collect all pieces from owner & partial owners. Duplicate
                    pieces are not helpful, every peer is looking for not-yet-seen pieces. As syncing
                    tends to reach end, peers start seeing more duplicates, which results into longer
                    sync time. Some pieces are rare, some are very rare and lots of peers attempting to collect
                    those rare pieces, resulting into <i>chaos in network</i>.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-client-server-vs-p2p.jpg">
                <p class="blogText">
                    For solving scope of rarest piece collection problem --- rather than
                    treating each piece as unique, I can combine fragments of pieces together and form whole new pieces,
                    which are not easily distinctive. From high level, it looks all pieces are more or less equally important.
                    Now peers don't collect original pieces from actual owner/ partial owners, rather they collect these
                    new pieces <i>( consisting of fragments of other pieces too )</i> and decode back to original when they've
                    collected enough useful pieces. While sharing these coded pieces, peers also share how have they combined
                    original pieces for constructing coded ones. Actually original pieces are randomly assigned some
                    coefficients/ weights i.e. pieces are added together while multiplying by respective random weights & coded pieces are formed. 
                    If there're N-many original pieces, atleast N-many useful coded pieces are required for reconstructing back
                    whole chunk.
                    <br>
                    <br>
                    This is what RLNC does, abstractly.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-coded-pieces.jpg">
                <p class="blogText">
                    I start with a byte slice i.e. <span class="highlight">[97, 110, 106, 97, 110]</span> which is owned
                    by N-many parties in p2p network. I could have asked one party to share that slice with me & I've the slice
                    now --- N+1 parties. But I can also ask M <i>( < N )</i>-many parties to share certain portion of slice
                    with me, concurrently, expecting I get whole slice faster. The effects are clearly visible when slice size is larger.
                    <br>
                    <br>
                    So I ask each of M-many peers to share few pieces with me, but wireless networks are unreliable inherently.
                    As my goal is reliably getting pieces as fast as possible, while transferring least possible bytes of data,
                    I decide to use coded piece distribution scheme. Each of M-many owner peers code original pieces & share coded pieces
                    with me, when I've enough of them, I decode them back to original byte slice. I can use RLNC for that.
                    <br>
                    <br>
                    If byte slice size is large, then I've to buffer all those coded pieces & at end when enough of them are collected,
                    I attempt to decode by performing computionally expensive large matrix inversion, which costs ~ O(n^3). First issue, I can't
                    understand what I'm receiving as I receive it, rather after I receive all, I try to figure out what I've received. I want to
                    have a scheme where I can work on decoded data, as I keep receiving remaining, while still enjoying benefits of network coding.
                    Second, I don't want to perform inversion of a large matrix. For solving second issue, I decide to split whole
                    byte slice into generations & pieces of each generation are coded together i.e. there're no cross-generation
                    coding/ decoding dependency. As generations are lot smaller in size, performing small matrix's inverse is not tiresome.
                    Introducing idea of generations also decreases waiting time before decoding to a great extent. But still for a single generation's
                    decoding, I've to wait for receiving all coded pieces of generation.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-idea-of-generation.jpg">
                <p class="blogText">
                    In following design, I'm going to consider byte slice <span class="highlight">[97, 110, 106, 97, 110]</span>
                    as single generation, with 5 pieces i.e. each piece consists of only single symbol.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-byte-slice.png">
                <p class="blogText">
                    My interest is in transferring this byte slice from M-many peers with as little coordination possible. The more
                    coordination, the more network traffic, the more bandwidth wastage. In plain & simple generational RLNC, randomly
                    coding coefficients are drawn from some agreed upon finite field. As coefficients are random, they need to be
                    accompanied with coded pieces for successful decoding.
                    <br>
                    <br>
                    As I've 5 pieces, I randomly choose 5 coefficients from <b>G</b>alois <b>F</b>ield (2**8), which has
                    256 elements & perform coding. Coded piece & coding vector, both are carried over wire to peer.
                </p>
                <div class="microlight">
 $ python3
 >>> import galois
 >>> gf = galois.GF(2**8)
 >>> data = [97, 110, 106, 97, 110]
 >>> gf(97)*gf(11) + gf(110)*gf(9) + gf(106)*gf(7) + gf(97)*gf(131) + gf(110)*gf(97)
 GF(122, order=2^8)

 >>> over_wire = {'coded_piece': 122, 'coding_vector': [11, 9, 7, 131, 97]}
                </div>
                <p class="blogText">
                    One way to avoid sending coding vector, which is an overhead, is pair of peers
                    agreeing upon seed, used for generating random coding coefficients. 
                    At beginning of session seed is shared & for rest of session it's used on receiver's
                    side for populating coding vectors --- now only <span class="highlight">{"coded_piece": 122}</span> sent over wire.
                    <br>
                    <br>
                    One important goal is to avoid obtaining linearly dependent pieces ( read useless pieces ), which is sometimes result of
                    randomly drawn coding coefficients. For sake for avoiding it, I choose to use prime numbers as coding coeffients.
                    <br>
                    <br>
                    Assume I'm working on a range, where I've 6 primes which are <span class="highlight">[2, 3, 5, 7, 11, 13]</span> & my original pieces
                    are <span class="highlight">[97, 110, 106, 97, 110]</span>. I want to code & generate 5 pieces, while using primes as coding
                    coefficients in ordered fashion, but I want to keep coordination as little as possible. I choose to use one sliding window technique,
                    where each piece's coeffients are chosen from one prime ring buffer based on selected <i>index</i>. For
                    coding index <b>i</b>, start with filling coding vector's index <b>i</b> with prime number at index <b>i</b> 
                    <i>( primes are ascending ordered in ring buffer )</i>, then following indices are filled with consequtive elements
                    from ring buffer. If coding index > 0, first few remaining positions are filled in circular way
                    with consequtive primes, continuing after point where left off while populating in forward direction.
                </p>
                <table class="centeredTable">
                    <tr>
                        <th>Original Piece</th>
                        <th>Coding Index</th>
                        <th>Coding Vector</th>
                        <th>Coded Piece</th>
                    </tr>
                    <tr>
                        <td rowspan="5">[97, 110, 106, 97, 110]</td>
                        <td>0</td>
                        <td>[2, 3, 5, 7, 11]</td>
                        <td>112</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>[13, 3, 5, 7, 11]</td>
                        <td>101</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>[13, 2, 5, 7, 11]</td>
                        <td>11</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>[13, 2, 3, 7, 11]</td>
                        <td>106</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>[13, 2, 3, 5, 11]</td>
                        <td>168</td>
                    </tr>
                </table>
                <img class="imgCenter" src="../images/p2p-sync-protocol-prime-ring-buffer-coding.jpg">
                <p class="blogText">
                    Actually I work on GF(2**8), having 256 elements i.e. from 0 to 255, it has 54 primes in range. I use these primes in ordered fashion for drawing
                    coefficients. But it's not only sufficient, I introduce concept of various kinds of coded pieces
                    based on how coding is being performed/ how coding coefficients are chosen.
                </p>
                <ul>
                    <li>Base Coded Piece</li>
                    <li>Decodable Coded Piece</li>
                    <li>Rich Coded Piece</li>
                </ul>
                <p class="blogText">
                    A base coded piece is constructed by taking coding vector with all elements set to 1.
                    As I work with original pieces <span class="highlight">[97, 110, 106, 97, 110]</span>,
                    I choose my base coding vector <span class="highlight">[1, 1, 1, 1, 1]</span>, resulting into
                    coded piece 106.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-base-coded-piece.png">
                <p class="blogText">
                    A decodable piece is same as base coded piece, except only one element of coding vector
                    is > 1. As I'm only interested in prime numbers as coding coefficients, I choose
                    from prime ring buffer as non-one coefficient. This piece is called decodable for a reason,
                    because it's very easily decodable when recipient party has one base coded piece too.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-decodable-coded-piece.png">
                <p class="blogText">
                    Assuming I've two pieces, one base coded piece i.e. <span class="highlight">[1, 1, 1, 1, 1, 106]</span>
                    & other one decodable coded piece i.e. <span class="highlight">[2, 1, 1, 1, 1, 201]</span>, I can instantly
                    figure out respective original piece, for which coding coefficient was chosen > 1.
                </p>
                <div class="microlight">
 >>> pieces = [[1, 1, 1, 1, 1, 106], [2, 1, 1, 1, 1, 201]]
 >>> gf(pieces).row_reduce() # 97 first piece, revealed
 GF([[ 1,  0,  0,  0,  0, 97],
    [ 0,  1,  1,  1,  1, 11]], order=2^8)
                </div>
                <p class="blogText">
                    A rich coded piece, is indeed rich with coding coefficients i.e. coding vector has all elements
                    set as > 1, where these elements are selected from prime ring buffer.
                </p>
                <img class="imgCenter" src="../images/p2p-sync-protocol-rich-coded-piece.png">
                <p class="blogText">
                    Question is, how to use these piece construction techniques, so that I can decrease chance
                    of getting duplicate coded pieces. I propose one way how peers can share pieces with recipient party
                    which reduces scope of encountering duplicate pieces, even when multiple peers are acting as sender
                    while maintaining little to no coordination among them.
                </p>
                <div class="microlight">
 begin:
    skip = S // provided by recipient
    begin_index = B // provided by recipient

    base_coded_piece = code(:base, pieces);
    send(base_coded_piece);
    with_rich = False;
    // N = original piece count in generation
    for (i = begin_index; i < N; i += skip):
        if with_rich:
            rich_coded_piece = code(:rich, pieces, i);
            send(rich_coded_piece, i);
        endif
        
        decodable_coded_piece = code(:decodable, pieces, i);
        send(decodable_coded_piece, i);
        
        // send rich piece every other round
        with_rich = !with_rich;
    endfor
 end
                </div>
                <p class="blogText">
                    As usual, I start with an example. Say, I want to have byte slice <span class="highlight">[97, 110, 106, 97, 110]</span>
                    from 2 peers whom I know having whole slice. Whole slice transfer is performed in single
                    generation.
                    I ask Peer_1 to start sending pieces from coding index 0, while using skip factor 2. I'm setting
                    skip factor 2, because I plan to connect to 2 peers & download pieces concurrently from both of them.
                    <br>
                    <br>
                    Peer_1 starts with sharing base coded piece, where all elements of coding vector are set to 1.
                    Resulting into construction of coded piece 106.
                    <br>
                    <br>
                    After that peer enters loop, where it prepares decodable piece, with coding index set as 0. For coding index <b>i</b>,
                    it takes prime at index <b>i</b>, from ring buffer, inserts at index <b>i</b> of coding
                    vector, populates all other elements by putting 1. Using this coding vector, it generates
                    one decodable coded piece 201.
                    One thing to notice, during first decodable coded piece sharing, Peer_1 hasn't shared
                    any rich piece. But in next round, it'll.
                    <br>
                    <br>
                    In this round, coding index is 2, so coding vector is constructed by filling index 2
                    of coding vector with prime number at index 2 i.e. 5 & other elements set to 1. This coding
                    vector is used for decodable piece. Constructed coded piece is 223. But this is the round when
                    rich piece also needs to be shared, which is prepared by constructing respective coding vector
                    i.e. starting at index 2, filling up with prime at index 2 i.e. 5 & circularly filling other places
                    by drawing next primes from ring buffer. This results into rich piece 23.
                    <br>
                    <br>
                    This round, peer works with coding index 4, so it prepares decodable piece by putting 11 i.e. prime
                    at index 4 from prime ring buffer, at index 4 of coding vector, while filling up other places with 1.
                    Finally it results into decodable coded piece 225.
                </p>
                <table class="centeredTable">
                    <tr>
                        <th rowspan="2">Original Pieces</th>
                        <th rowspan="2">Coding Vector</th>
                        <th rowspan="2">Piece Type</th>
                        <th colspan="2">Over-the-Wire</th>
                    </tr>
                    <tr>
                        <th>Coding Index</th>
                        <th>Coded Piece</th>
                    </tr>
                    <tr>
                        <td rowspan="5">[97, 110, 106, 97, 110]</td>
                        <td>[1, 1, 1, 1, 1]</td>
                        <td>Base</td>
                        <td>NaN</td>
                        <td>106</td>
                    </tr>
                    <tr>
                        <td>[2, 1, 1, 1, 1]</td>
                        <td>Decodable</td>
                        <td>0</td>
                        <td>201</td>
                    </tr>
                    <tr>
                        <td>[1, 1, 5, 1, 1]</td>
                        <td>Decodable</td>
                        <td>2</td>
                        <td>223</td>
                    </tr>
                    <tr>
                        <td>[13, 17, 5, 7, 11]</td>
                        <td>Rich</td>
                        <td>2</td>
                        <td>23</td>
                    </tr>
                    <tr>
                        <td>[1, 1, 1, 1, 11]</td>
                        <td>Decodable</td>
                        <td>4</td>
                        <td>225</td>
                    </tr>
                </table>
                <img class="imgCenter" src="../images/p2p-sync-protocol-peer-1-protocol-flow.jpg">
                <p class="blogText">
                    On the other hand, I ask Peer_2 to start at coding index 1, while using skip factor 2, due to
                    presence of two concurrent peers.
                    <br>
                    <br>
                    Peer_2 starts by sharing base coded piece, which is exactly same as what Peer_1 has also
                    shared.
                    <br>
                    <br>
                    Now it starts looping, with coding index 1, prepares coding vector by putting
                    1st prime number i.e. 3 of ring buffer, at index 1 of coding vector & all other places
                    filled with 1. Constructed decodable coded piece is 182.
                    <br>
                    <br>
                    This is the round, when rich piece to be also shared, along with decodable piece. With coding index 3,
                    because skip factor set to 2, first prepares coding vector for decodable piece, which results into
                    piece 49. For coding vector of rich piece, starts with filling up vector at index 3, with
                    3rd prime number 7, while putting next primes from ring buffer in circular fashion into
                    remaining places. As a result of it, constructed piece is 152.
                </p>
                <table class="centeredTable">
                    <tr>
                        <th rowspan="2">Original Pieces</th>
                        <th rowspan="2">Coding Vector</th>
                        <th rowspan="2">Piece Type</th>
                        <th colspan="2">Over-the-Wire</th>
                    </tr>
                    <tr>
                        <th>Coding Index</th>
                        <th>Coded Piece</th>
                    </tr>
                    <tr>
                        <td rowspan="5">[97, 110, 106, 97, 110]</td>
                        <td>[1, 1, 1, 1, 1]</td>
                        <td>Base</td>
                        <td>NaN</td>
                        <td>106</td>
                    </tr>
                    <tr>
                        <td>[1, 3, 1, 1, 1]</td>
                        <td>Decodable</td>
                        <td>1</td>
                        <td>182</td>
                    </tr>
                    <tr>
                        <td>[1, 1, 1, 7, 1]</td>
                        <td>Decodable</td>
                        <td>3</td>
                        <td>49</td>
                    </tr>
                    <tr>
                        <td>[13, 17, 19, 7, 11]</td>
                        <td>Rich</td>
                        <td>3</td>
                        <td>152</td>
                    </tr>
                </table>
                <img class="imgCenter" src="../images/p2p-sync-protocol-peer-2-protocol-flow.jpg">
            </article>
        </div>
    </div>
    <div id="footerDiv">
        <footer>
            <p id="footerText">
                &copy <a href="https://github.com/itzmeanjan/itzmeanjan.github.io" id="footerLink"
                    target="_blank"><big>A</big>njan Roy</a> ( <big>M</big>IT Licensed )
            </p>
        </footer>
    </div>
</body>

</html>
